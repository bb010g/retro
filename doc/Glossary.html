<h1>*</h1>
<p>  Data:  nn-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Multiply `n1` by `n2` and return the result.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #2 #6 *
    #-1 #100 *

</xmp><hr/>
<h1>+</h1>
<p>  Data:  nn-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Add `n1` to `n2` and return the result.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #1 #2 + 

</xmp><hr/>
<h1>,</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Store the specified value into the memory at `here` and increment `Heap` by 1.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    $a , $b , $c , #0 ,

</xmp><hr/>
<h1>-</h1>
<p>  Data:  nn-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Subtract `n2` from `n1` and return the result.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #2 #1 - 

</xmp><hr/>
<h1>---reveal---</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Switch to the exposed (public) portion of a lexical namespace.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>-eq?</h1>
<p>  Data:  nn-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compare two values for inequality. Returns `TRUE` if they are not equal or `FALSE` otherwise.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #1 #2 -eq?
    $a $b -eq?

</xmp><hr/>
<h1>-if</h1>
<p>  Data:  fq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the quotation if the flag is `FALSE`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>-if;</h1>
<p>  Data:  fq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the quotation if the flag is `FALSE`. If false, also exit the word.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>/</h1>
<p>  Data:  mn-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Divide `m` by `n` and return the result.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>/mod</h1>
<p>  Data:  nm-op
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Divide `n` by `m` and return the result and remainder.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>0;</h1>
<p>  Data:  n-n || n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>If `n` is zero, drop `n` and exit the current word. If non-zero, leave `n` alone and allow execution to continue.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>;</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>End the current definition.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>?dup</h1>
<p>  Data:  n-nn || n-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Duplicate top value on stack if not zero. If zero, do nothing.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #1 ?dup
    #0 ?dup

</xmp><hr/>
<h1>ASCII:ACK</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:BEL</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:BS</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:CAN</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:CR</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:DC1</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:DC2</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:DC3</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:DC4</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:DEL</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:DLE</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:EM</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:ENQ</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:EOT</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:ESC</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:ETB</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:ETX</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:FF</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:FS</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:GS</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:HT</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:LF</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:NAK</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:NUL</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:RS</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:SI</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:SO</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:SOH</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:SPACE</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:STX</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:SUB</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:SYN</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:US</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>ASCII:VT</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Refers to specific ASCII code.

</p>
<p>Class: class:data | Namespace: ASCII | Interface Layer: all</p>
<hr/>
<h1>Compiler</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. Holds the compiler state. If TRUE, the compiler is active. If FALSE, it is not.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>Dictionary</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. Holds a pointer to the most recent dictionary header.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>EOM</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Returns the last addressable memory address.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>FALSE</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Returns `0`, the value used to indicate a FALSE result.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>FREE</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Returns the number of cells available to your application. This is the amount of memory, less the already consumed portion and buffers mapped for RETRO's internal use.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>Heap</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. Holds the address of the next available cell.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>I</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Access the loop index for the current loop. (For loops made using `times&lt;with-index&gt;`)

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>J</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Access the parent loop index for the current loop. (For loops made using `times&lt;with-index&gt;`)

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>K</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Access the grandparent loop index for the current loop. (For loops made using `times&lt;with-index&gt;`)

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>NoEcho</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. If TRUE, allow display of the "ok" prompt and startup banner.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: rre</p>
<hr/>
<h1>RewriteUnderscores</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. When set to `TRUE`, RETRO will replace underscores in strings with spaces. When `FALSE`, RETRO does not.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>STRINGS</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the address of the start of the temporary string pool.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>ScopeList</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. This holds some information used by `{{` and `}}`.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>TRUE</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Returns `-1`, the value used to indicate a TRUE result.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>TempStringMax</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. Holds the maximum length of a temporary string.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>TempStrings</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. Holds the number of temporary strings.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>Version</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Variable. This stores the version number.

</p>
<p>Class: class:data | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>[</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Begin a quotation.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>]</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>End a quotation.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>again</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Close an unconditional loop. Branches back to the prior `repeat`.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>allot</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Allocate the specified number of cells from the `Heap`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    'Buffer d:create  #100 allot

</xmp><hr/>
<h1>and</h1>
<p>  Data:  nm-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Perform a bitwise AND operation between the two provided values.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>as{</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Begin an assembly section.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>banner</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a welcome message on startup.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: rre</p>
<hr/>
<h1>bi</h1>
<p>  Data:  xqq-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute q1 against x, then execute q2 against a copy of x.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #100 [ #10 * ] [ #10 - ] bi

</xmp><hr/>
<h1>bi*</h1>
<p>  Data:  xyqq-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute q1 against x and q2 against y.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #10 #20 [ #2 * ] [ #10 / ] bi*

</xmp><hr/>
<h1>bi@</h1>
<p>  Data:  xyq-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute q against x, then execute q against y.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #10 #20 [ #3 * ] bi@

</xmp><hr/>
<h1>buffer:add</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Append a value to the current buffer.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>buffer:empty</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Reset the current buffer to an empty state.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>buffer:end</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a pointer to the current end of the active buffer.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>buffer:get</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Remove the last value from the current buffer.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>buffer:preserve</h1>
<p>  Data:  q-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Save and restore the current buffer before and after executing the specified quote.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>buffer:set</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Assign a new buffer as the current one.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>buffer:size</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the number of cells in the buffer.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>buffer:start</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the start address of the current buffer.

</p>
<p>Class: class:word | Namespace: buffer | Interface Layer: all</p>
<hr/>
<h1>bye</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Exit RETRO.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: rre</p>
<hr/>
<h1>c:-consonant?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is a not consonant or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:-digit?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is a not numeric digit or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:-lowercase?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is not lowercase or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:-uppercase?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is not uppercase or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:-visible?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is not printable or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:-vowel?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is not a vowel or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:-whitespace?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is not whitespace, or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:consonant?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is a consonant or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:digit?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is a numeric digit or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:get</h1>
<p>  Data:  -c
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Read a single keypress.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: rre</p>
<hr/>
<h1>c:letter?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is an ASCII letter or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:lowercase?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is lowercase or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:put</h1>
<p>  Data:  c-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a single character.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>c:to-lower</h1>
<p>  Data:  c-c
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert character to lowercase equivalent.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:to-number</h1>
<p>  Data:  c-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert an ASCII digit character into the corresponding decimal value

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>c:to-string</h1>
<p>  Data:  c-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert character into a string.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:to-upper</h1>
<p>  Data:  c-c
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert character to uppercase equivalent.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:toggle-case</h1>
<p>  Data:  c-c
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert an ASCII character to the opposite case.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:uppercase?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is uppercase or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:visible?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is printable or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:vowel?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is a vowel or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>c:whitespace?</h1>
<p>  Data:  c-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if character is whitespace, or FALSE otherwise.

</p>
<p>Class: class:word | Namespace: c | Interface Layer: all</p>
<hr/>
<h1>call</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Call a function.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>case</h1>
<p>  Data:  nmq- || nmq-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>If `n` is equal to `m`, drop both and execute the specified quote before exiting the calling word. If not equal, leave `n` on the stack and let execution continue.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>choose</h1>
<p>  Data:  fqq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute q1 if the flag is true (-1) or q2 if the flag is false (0). Only these flags are valid when using `choose`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>class:data</h1>
<p>  Data:  n- || n-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Class handler for data structures.

</p>
<p>Interpret Time:
  Keep the address or value on the stack.</p>

<p>Compile Time:
  Compile the value or address as a literal into the current definition.</p>

<p>Class: class:word | Namespace: class | Interface Layer: all</p>
<hr/>
<h1>class:macro</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Class handler for compiler macros (immediate words)

</p>
<p>Interpret Time:
  Execute the function at the provided address.</p>

<p>Compile Time:
  Execute the function at the provided address.</p>

<p>Class: class:word | Namespace: class | Interface Layer: all</p>
<hr/>
<h1>class:primitive</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Class handler for primitive words (words which map to Nga instructions)

</p>
<p>Interpret Time:
  Execute the function.</p>

<p>Compile Time:
  Compile the machine code in the definiton into the current definition.</p>

<p>Class: class:word | Namespace: class | Interface Layer: all</p>
<hr/>
<h1>class:word</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Class handler for normal words.

</p>
<p>Interpret Time:
  Execute the function at the provided address.</p>

<p>Compile Time:
  Compile a call to the specified address into the current definition.</p>

<p>Class: class:word | Namespace: class | Interface Layer: all</p>
<hr/>
<h1>clock:day</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the current day.

</p>
<p>Class: class:word | Namespace: clock | Interface Layer: iOS</p>
<hr/>
<h1>clock:hour</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the current hour.

</p>
<p>Class: class:word | Namespace: clock | Interface Layer: iOS</p>
<hr/>
<h1>clock:minute</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the current minute.

</p>
<p>Class: class:word | Namespace: clock | Interface Layer: iOS</p>
<hr/>
<h1>clock:month</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the current month.

</p>
<p>Class: class:word | Namespace: clock | Interface Layer: iOS</p>
<hr/>
<h1>clock:second</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the current second.

</p>
<p>Class: class:word | Namespace: clock | Interface Layer: iOS</p>
<hr/>
<h1>clock:year</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the current year.

</p>
<p>Class: class:word | Namespace: clock | Interface Layer: iOS</p>
<hr/>
<h1>compile:call</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compile a call to the specified address into the current definition.

</p>
<p>Class: class:word | Namespace: compile | Interface Layer: all</p>
<hr/>
<h1>compile:jump</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compile a jump to the specified address into the current definition.

</p>
<p>Class: class:word | Namespace: compile | Interface Layer: all</p>
<hr/>
<h1>compile:lit</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compile the code to push a number to the stack into the current definition.

</p>
<p>Class: class:word | Namespace: compile | Interface Layer: all</p>
<hr/>
<h1>compile:ret</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compile a return instruction into the current definition.

</p>
<p>Class: class:word | Namespace: compile | Interface Layer: all</p>
<hr/>
<h1>compiling?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if compiler is on or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>const</h1>
<p>  Data:  ns-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Create a constant returning the specified value.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>copy</h1>
<p>  Data:  sdl-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Copy `l` cells from memory at `s` to the memory at `d`. These should not overlap.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>curry</h1>
<p>  Data:  nq-q
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Bind a value to a function and return a new quote that calls the bound action.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>d</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Inline a numeric value to the current assembly segment.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>d:add-header</h1>
<p>  Data:  saa-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Create a header. Provide a string (s) for the name, a pointer to the class handler (a1) and a pointer to the word definition (a2) Generally this won't be used directly.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:class</h1>
<p>  Data:  d-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a dictionary header, return the class field.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:create</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Create a new dictionary header named the specified string. The new header will point to `here` and have a class of `class:data`.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:for-each</h1>
<p>  Data:  q-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the specified quote once for each header in the dictionary. Before running the quote, this also pushes a pointer to the header onto the stack.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:last</h1>
<p>  Data:  -d
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the most recent dictionary header.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:last&lt;class&gt;</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a pointer to the class field of the most recent dictionary header.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:last&lt;name&gt;</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a pointer to the name field of the most recent dictionary header.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:last&lt;xt&gt;</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a pointer to the xt field of the most recent dictionary header.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:link</h1>
<p>  Data:  d-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a dictionary header, return the link field.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:lookup</h1>
<p>  Data:  s-d
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Lookup the specified name in the dictionary and return a pointer to its dictionary header. This returns zero if the word is not found.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:lookup-xt</h1>
<p>  Data:  a-d
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Lookup the specified address in the dictionary and return a pointer to its dictionary header. This returns zero if the word is not found.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:name</h1>
<p>  Data:  d-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a dictionary header, return the name field.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>d:words</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a list of all named items in the `Dictionary`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>d:words-with</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a list of all named items in the `Dictionary` that contain the provided substring.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>d:xt</h1>
<p>  Data:  d-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a dictionary header, return the xt field.

</p>
<p>Class: class:word | Namespace: d | Interface Layer: all</p>
<hr/>
<h1>data</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Change the class of the most recently defined word to `class:data`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>depth</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the number of items on the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>dip</h1>
<p>  Data:  nq-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Temporarily remove n from the stack, execute the quotation, and then restore n to the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>does</h1>
<p>  Data:  q-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Attach an action to the most recently created word. This is used in a manner similar to CREATE/DOES&gt; in traditional Forth.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>drop</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Discard the top value on the stack.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>drop-pair</h1>
<p>  Data:  nn-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Remove top two items on the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>dump-stack</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display the items on the data stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>dup</h1>
<p>  Data:  n-nn
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Duplicate the top item on the stack.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>dup-pair</h1>
<p>  Data:  nm-nmnm
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Duplicate the top two items on the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>eq?</h1>
<p>  Data:  nn-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compare two values for equality. Returns `TRUE` if they are equal or `FALSE` otherwise.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #1 #2 eq?
    $a $b eq?

</xmp><hr/>
<h1>err:notfound</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Error handler. Called when a word is not found by `interpret`.

</p>
<p>Class: class:word | Namespace: err | Interface Layer: all</p>
<hr/>
<h1>f:*</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-F

</p>
<p>Multiply two floating point numbers, returning the result.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<xmp>
Example #1:

    .3.1415 .22 f:*

</xmp><hr/>
<h1>f:+</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-F

</p>
<p>Add two floating point numbers, returning the result.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<xmp>
Example #1:

    .3.1 .22 f:+

</xmp><hr/>
<h1>f:-</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-F

</p>
<p>Subtract F2 from F1 returing the result.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<xmp>
Example #1:

    .22.3 .0.12 f:-

</xmp><hr/>
<h1>f:-INF</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -n

</p>
<p>Return a value corresponding to negative infinity

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:-eq?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-

</p>
<p>Compare two floating point values for inequality. Returns `TRUE` if they are not equal or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:-inf?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Return `TRUE` if floating point value is -INF or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:/</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-F

</p>
<p>Divide floating point value F1 by F2.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:E</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -F

</p>
<p>Return the floating point value for Euler's number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:INF</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -n

</p>
<p>Return a value corresponding to positive infinity

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:NAN</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -n

</p>
<p>Return a value corresponding to NaN

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:PI</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -F

</p>
<p>Return the floating point value for PI.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:abs</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-F

</p>
<p>Return the absolute value for a floating point value.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:acos</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: f-f

</p>
<p>Return the arc cosine of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:asin</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: f-f

</p>
<p>Return the arc sine of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:atan</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: f-f

</p>
<p>Return the arc tangent of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:ceiling</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-F

</p>
<p>Return the smallest integral value greater than or equal to the specified value.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:cos</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: f-f

</p>
<p>Return the cosine of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:depth</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the number of items on the floating point stack.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:drop</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Discard the top item on the floating point stack.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:dup</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-FF

</p>
<p>Duplicate the top item on the floating point stack.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:eq?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-

</p>
<p>Compare two floating point values for equality. Returns `TRUE` if they are equal or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:fetch</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -n

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>f:floor</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-F

</p>
<p>Perform a mathmatical floor operation on the floating point value.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:gt?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-

</p>
<p>Compare two floating point values for greater than.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:inf?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Return `TRUE` if floating point value is INF or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:log</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-F

</p>
<p>Return log(F1) for base F2 for floating point values.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:lt?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-

</p>
<p>Compare two floating point values for less than.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:nan?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Return `TRUE` if floating point value is NaN or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:negate</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-F

</p>
<p>Invert the sign of the floating point value.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<xmp>
Example #1:

    .3.1415 f:negate

</xmp><hr/>
<h1>f:negative?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Return `TRUE` if floating point value is negative or `FALSE` if not.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:over</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FG-FGF

</p>
<p>Put a copy of the second floating point value over the top one.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:positive?</h1>
<p>  Data:  -f
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Return `TRUE` if floating point value is positive or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:power</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FF-F

</p>
<p>Return F1^F2 for floating point values.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:put</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Display a floating point number.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: rre</p>
<hr/>
<h1>f:round</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: f-f

</p>
<p>Round a floating point value.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:sin</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-F

</p>
<p>Return the sine of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:sqrt</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-F

</p>
<p>Return the square root of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:square</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: f-f

</p>
<p>Return the square of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:store</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: n-

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>f:swap</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FG-GF

</p>
<p>Exchange the top and second items on the floating point stack.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:tan</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: F-F

</p>
<p>Return the tangent of a floating point number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:to-number</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Convert a floating point value into a number.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:to-string</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: F-

</p>
<p>Convert a floating point value into a string.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>f:to-u</h1>
<p>  Data:  -u
</p>
<p>  Addr:  -
</p>
<p>  Float: n-

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>f:tuck</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: FG-GFG

</p>
<p>Tuck a copy of the top floating point value under the second one.

</p>
<p>Class: class:word | Namespace: f | Interface Layer: rre</p>
<hr/>
<h1>fetch</h1>
<p>  Data:  a-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Fetch the value stored at the specified address.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    &Version fetch

</xmp><hr/>
<h1>fetch-next</h1>
<p>  Data:  a-an
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Fetch the value stored at the specified address. Returns the next address and the value.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>file:A</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant for opening a file in APPEND mode.

</p>
<p>Class: class:data | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:R</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant for opening a file in READ mode.

</p>
<p>Class: class:data | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:R+</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant for opening a file in READ &amp; WRITE mode.

</p>
<p>Class: class:data | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:W</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant for opening a file in WRITE mode.

</p>
<p>Class: class:data | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:close</h1>
<p>  Data:  h-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file handle, close the file.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:delete</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Delete the named file.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:exists?</h1>
<p>  Data:  s-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file name, return `TRUE` if it exists or `FALSE` if it does not.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:flush</h1>
<p>  Data:  h-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file handle, flush any pending writes to disk.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:for-each-line</h1>
<p>  Data:  sq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file name, open it and run the quote once for each line in the file.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:open</h1>
<p>  Data:  sm-h
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Open a named file (s) with the given mode (m). Returns a handle identifying the file.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<xmp>
Example #1:

  '/etc/motd file:R file:open

</xmp><hr/>
<h1>file:open&lt;for-append&gt;</h1>
<p>  Data:  s-nn
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Open a file for reading &amp; writing. Returns the size (NOS) and a file ID (TOS)

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:open&lt;for-reading&gt;</h1>
<p>  Data:  s-nn
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Open a file for reading. Returns the size (NOS) and a file ID (TOS)

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:open&lt;for-writing&gt;</h1>
<p>  Data:  s-nn
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Open a file for reading. Returns the file ID

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:read</h1>
<p>  Data:  h-c
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file handle, read and return the next character in it.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:read-line</h1>
<p>  Data:  f-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file handle, read a line and return a pointer to it.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:seek</h1>
<p>  Data:  nh-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Move the current offset into a file to the specified one.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:size</h1>
<p>  Data:  h-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file handle, return the size of the file (in bytes).

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:slurp</h1>
<p>  Data:  as-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given an address and a file name, read the file contents into memory starting at the address.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:spew</h1>
<p>  Data:  ss-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a string (s1) and a file name (s2), write the string into the file, replacing any existing cotent.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:tell</h1>
<p>  Data:  h-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given a file handle, return the current offset in the file.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>file:write</h1>
<p>  Data:  ch-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Write a character to the file represented by the handle.

</p>
<p>Class: class:word | Namespace: file | Interface Layer: rre</p>
<hr/>
<h1>gopher:get</h1>
<p>  Data:  asns-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Takes an address, a server, a port, and a selector. Fetch the resource and store it at address. Return the number of bytes received.

</p>
<p>Class: class:word | Namespace: gopher | Interface Layer: rre</p>
<xmp>
Example #1:

    here 'forthworks.com #70 '/ gopher:get
    here s:put

</xmp><hr/>
<h1>gt?</h1>
<p>  Data:  nn-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compare n1 and n2. Return `TRUE` if n1 is greater than n2, or `FALSE` otherwise.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>gteq?</h1>
<p>  Data:  nn-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compare n1 and n2. Return `TRUE` if n1 is greater than or equal to n2, or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>here</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the next free address in memory.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>hook</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Add a hook point into the current word. This should only be used as the first word in a definition.

</p>
<p>Class: class:macro | Namespace: {n/a} | Interface Layer: global</p>
<xmp>
Example #1:

    :foo hook ;

</xmp><hr/>
<h1>i</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Assemble the instructions specified by the string into the current assembly scope.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>if</h1>
<p>  Data:  fq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the quote if the flag is `TRUE`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>if;</h1>
<p>  Data:  fq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the quotation if the flag is `TRUE`. If true, also exit the word.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>immediate</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Change the class of the most recently defined word to `class:macro`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>include</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Run the code in the specified file. 

</p>
<p>Class: class:word | Namespace: global | Interface Layer: rre</p>
<hr/>
<h1>interpret</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Interpret a single input token.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    '#100 interpret
    'words interpret

</xmp><hr/>
<h1>io:enumerate</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the number of I/O devices.

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: all</p>
<hr/>
<h1>io:file-operation</h1>
<p>  Data:  ...n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Trigger a file I/O operation. This is not intended to be used directly.

</p>
<p>Class: class:word | Namespace: io | Interface Layer: rre</p>
<hr/>
<h1>io:float-operation</h1>
<p>  Data:  ...n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Trigger a floating point operation. This is not intended to be used directly.

</p>
<p>Class: class:word | Namespace: io | Interface Layer: rre</p>
<hr/>
<h1>io:invoke</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Invoke an interaction with an I/O device.

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: all</p>
<hr/>
<h1>io:query</h1>
<p>  Data:  n-mN
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Ask an I/O device to identify itself. Returns a version (m) and device ID (N).

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: all</p>
<hr/>
<h1>io:scan-for</h1>
<p>  Data:  n-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Scan the I/O devices for a device with a specified ID. Returns the device number, or -1 if not found.

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: all</p>
<hr/>
<h1>io:unix-syscall</h1>
<p>  Data:  ...n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Trigger a Unix system call. This is not intended to be used directly.

</p>
<p>Class: class:word | Namespace: io | Interface Layer: rre</p>
<hr/>
<h1>ios:list-fonts</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a list of all installed fonts.

</p>
<p>Class: class:word | Namespace: ios | Interface Layer: iOS</p>
<hr/>
<h1>listen</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Run interactive "listener" (a REPL).

</p>
<p>Class: class:word | Namespace: global | Interface Layer: rre</p>
<hr/>
<h1>lt?</h1>
<p>  Data:  nn-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compare n1 and n2. Return `TRUE` if n1 is less than n2, or `FALSE` otherwise.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>lteq?</h1>
<p>  Data:  nn-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compare n1 and n2. Return `TRUE` if n1 is less than or equal to n2, or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>mod</h1>
<p>  Data:  nm-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Divide `n` by `m` and return the remainder.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>n:-zero?</h1>
<p>  Data:  n-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if number is not zero, or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:MAX</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the maximum value that will fit in a cell.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:MIN</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the minimum value that will fit in a cell.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:abs</h1>
<p>  Data:  n-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the absolute value of a number.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #10 n:abs
    #-10 n:abs


</xmp><hr/>
<h1>n:between?</h1>
<p>  Data:  nlu-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if number is between the lower (l) and upper (u) bounds. If not, return FALSE. This is inclusive of the limits.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #3 #1 #100 n:between?
    $q $a $b   n:between?

</xmp><hr/>
<h1>n:dec</h1>
<p>  Data:  n-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Decrement n by one.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #100 n:dec

</xmp><hr/>
<h1>n:even?</h1>
<p>  Data:  n-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if number is even, or `FALSE` if not.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #12 n:even?
    #11 n:even?

</xmp><hr/>
<h1>n:inc</h1>
<p>  Data:  n-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Increment n by one.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #100 n:inc

</xmp><hr/>
<h1>n:limit</h1>
<p>  Data:  nlu-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return n if it is within the lower (l) and upper (u) bounds. If outside the bounds, return the closes boundary value.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #-10 #5 #8 n:limit
    #10  #1 #15 n:limit

</xmp><hr/>
<h1>n:max</h1>
<p>  Data:  mn-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the greater of two values.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #1 #7 n:max
    #-8 #-10 n:max

</xmp><hr/>
<h1>n:min</h1>
<p>  Data:  mn-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the lesser of two values.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #1 #7 n:min
    #-8 #-10 n:min

</xmp><hr/>
<h1>n:negate</h1>
<p>  Data:  n-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Invert the sign of a number.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<xmp>
Example #1:

    #10 n:negate
    #-10 n:negate

</xmp><hr/>
<h1>n:negative?</h1>
<p>  Data:  n-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if number is negative, or `FALSE` if not.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:odd?</h1>
<p>  Data:  n-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if number is odd, or `FALSE` if not.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:positive?</h1>
<p>  Data:  n-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if number is positive, or `FALSE` if not.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:pow</h1>
<p>  Data:  bp-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return base (b) to power (p).

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:put</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a number.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>n:random</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a random number

</p>
<p>Class: class:word | Namespace: n | Interface Layer: rre, ri</p>
<xmp>
Example #1:

    n:random n:put

</xmp><hr/>
<h1>n:sqrt</h1>
<p>  Data:  n-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the square root of a number.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:square</h1>
<p>  Data:  n-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the square of a number.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:strictly-positive?</h1>
<p>  Data:  n-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return TRUE if number is greater than zero or FALSE if it is zero or less.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:to-float</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -F

</p>
<p>Convert a number into a floating point value.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: rre</p>
<hr/>
<h1>n:to-string</h1>
<p>  Data:  n-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert a number into a string.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>n:zero?</h1>
<p>  Data:  n-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if number is zero, or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: n | Interface Layer: all</p>
<hr/>
<h1>nip</h1>
<p>  Data:  nm-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Remove the second item from the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>nl</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a newline.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>not</h1>
<p>  Data:  n-m
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Perform a logical NOT operation.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>or</h1>
<p>  Data:  mn-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Perform a bitwise OR between the provided values.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>over</h1>
<p>  Data:  nm-nmn
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Put a copy of n over m.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>parse-until</h1>
<p>  Data:  q-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Read input from stdin (via `c:get`) until the returned character is matched by the quote. Returns a string.

</p>
<p>Class: class:word | Namespace: all | Interface Layer: rre</p>
<xmp>
Example #1:

  :read-until-period (-s)
    [ $. eq? ] parse-until ;

</xmp><hr/>
<h1>pb:get</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Copy a string from the pasteboard to the specified address.

</p>
<p>Class: class:word | Namespace: pb | Interface Layer: iOS</p>
<hr/>
<h1>pb:length</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the length of the string on the pasteboard.

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: iOS</p>
<xmp>
Example #1:

pb

</xmp><hr/>
<h1>pb:set</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Copy a string to the pasteboard.

</p>
<p>Class: class:word | Namespace: pb | Interface Layer: iOS</p>
<hr/>
<h1>pop</h1>
<p>  Data:  -n
</p>
<p>  Addr:  n-
</p>
<p>  Float: -

</p>
<p>Move a value from the return stack to the data stack.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>prefix:!</h1>
<p>  Data:  ns-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Store a value into a variable.

</p>
<p>Interpret Time:
  Store a value into the named variable.</p>

<p>Compile Time:
  Compile the code to store a value into a named variable.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:"</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Process token as a string.

</p>
<p>Interpret Time:
  Keep string as permanent. If `RewriteUnderscores` is `TRUE`, replace all instances of _ with space.</p>

<p>Compile Time:
  Keep string as permanent. If `RewriteUnderscores` is `TRUE`, replace all instances of _ with space. Then compile the string into the current definition.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:#</h1>
<p>  Data:  s-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Process token as a number.

</p>
<p>Interpret Time:
  Convert the string into a number and leave on the stack.</p>

<p>Compile Time:
  Convert the string into a number and compile into the current definition as a literal.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:$</h1>
<p>  Data:  s-c
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Process token as an ASCII character.

</p>
<p>Interpret Time:
  Fetch first character from string. Leave on stack.</p>

<p>Compile Time:
  Fetch first character from the string. Compile into the current definition as  literal.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:&amp;</h1>
<p>  Data:  s-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a pointer to a named item.

</p>
<p>Interpret Time:
  Lookup name in dictionary, return contents of the xt field on the stack.</p>

<p>Compile Time:
  Lookup name in dictionary, compile code to push the contents of the xt field into the current definition.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:'</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Process token as a string.

</p>
<p>Interpret Time:
  Move string into temporary buffer. If `RewriteUnderscores` is `TRUE`, replace all instances of _ with space.</p>

<p>Compile Time:
  Move string into temporary buffer. If `RewriteUnderscores` is `TRUE`, replace all instances of _ with space. Then compile the string into the current definition.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:(</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Process token as a comment.

</p>
<p>Interpret Time:
  Discard the string.</p>

<p>Compile Time:
  Discard the string.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:.</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -F

</p>
<p>Interpret time: convert string to a floating point value. Compile time: convert string to a floating point value and compile code to push this value to the float stack.

</p>
<p>Class: class:macro | Namespace: prefix | Interface Layer: rre</p>
<hr/>
<h1>prefix::</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Process token as a new definition.

</p>
<p>Interpret Time:
  Create a header pointing to `here` with the provided string as the name. Sets class to `class:word`.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:@</h1>
<p>  Data:  s-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Fetch from a stored variable.

</p>
<p>Interpret Time:
  Fetch a value from a named variable.</p>

<p>Compile Time:
  Compile the code to fetch a value from a named variable into the current definition.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:`</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Process token as a bytecode.

</p>
<p>Interpret Time:
  Discard the string.</p>

<p>Compile Time:
  Convert the string to a number and use `,` to inline it into the current definition.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>prefix:|</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>POSTPONE equivilent.

</p>
<p>Interpret Time:
  Discard the string.</p>

<p>Compile Time:
  Convert the string to a number and use `,` to inline it into the current definition.</p>

<p>Class: class:macro | Namespace: prefix | Interface Layer: all</p>
<hr/>
<h1>primitive</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Change the class of the most recently defined word to `class:primitive`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>push</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -n
</p>
<p>  Float: -

</p>
<p>Move a value from the data stack to the return stack.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>r</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Lookup a reference by name and inline its pointer to the current assembly segment.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>random:mersenne</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a random number using a mersenne shifter

</p>
<p>Class: class:word | Namespace: random | Interface Layer: rre, ri</p>
<hr/>
<h1>random:mersenne:set-seed</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Seed random:mersenne with the specified value

</p>
<p>Class: class:word | Namespace: random | Interface Layer: rre, ri</p>
<hr/>
<h1>random:xoroshiro128**</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a random number using xoroshiro128**

</p>
<p>Class: class:word | Namespace: random | Interface Layer: rre, ri</p>
<hr/>
<h1>random:xoroshiro128**:set-seed</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Seed random:xoroshiro128** with the specified value

</p>
<p>Class: class:word | Namespace: random | Interface Layer: rre, ri</p>
<hr/>
<h1>reclass</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Change the class handler of the most recently defined word to the specified one.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>reorder</h1>
<p>  Data:  ...ss-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Restructure the order of items on the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>repeat</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Begin an unconditional loop.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>reset</h1>
<p>  Data:  ...-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Remove all items from the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>rot</h1>
<p>  Data:  abc-bca
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Rotate the top three values.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>s,</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compile the code needed to push a string pointer to the stack and inline the string data into the current definition.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>s:ASCII-LETTERS</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Returns a string of the ASCII letters (upper and lower case)

</p>
<p>Class: class:data | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:ASCII-LOWERCASE</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Returns a string of the ASCII letters in lowercase

</p>
<p>Class: class:data | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:ASCII-UPPERCASE</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Returns a string of the ASCII letters in uppercase

</p>
<p>Class: class:data | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:DIGITS</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Return a string of characters recognized as numeric digits.

</p>
<p>Class: class:data | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:PUNCTUATION</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Return a string of characters recognized as punctuation.

</p>
<p>Class: class:data | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:WHITESPACE</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Constant. Returns a string of characters recognized as whitespace.

</p>
<p>Class: class:data | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:append</h1>
<p>  Data:  ss-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a new string consisting of s1 followed by s2.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:case</h1>
<p>  Data:  sSq- || sSq-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>If the `s` matches `S`, discard `s` and run the quote before exiting the caller. If they do not match, discard the quote and leave `s` on the stack.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:chop</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Remove the last character from a string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:const</h1>
<p>  Data:  ss-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Create a constant named s2, returning a pointer to s1. This will use `s:keep` to preserve the original string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:contains-char?</h1>
<p>  Data:  sc-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if the character is present in the string or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:contains-string?</h1>
<p>  Data:  ss-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if the second string is present in the first string or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:copy</h1>
<p>  Data:  sa-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Copy a string (s) to a destination (a). This will include the terminator character when copying.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:empty</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return an empty string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:eq?</h1>
<p>  Data:  ss-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Compare two strings for equality. Return `TRUE` if identical or `FALSE` if not.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<xmp>
Example #1:

    'hello 'again s:eq?
    'test  'test  s:eq?

</xmp><hr/>
<h1>s:evaluate</h1>
<p>  Data:  s-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Evaluate string as if it was typed into the interpreter.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:filter</h1>
<p>  Data:  sq-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the quote once for each value in the string. If the quote returns `TRUE`, append the value into a new string. If `FALSE` the value will be discarded.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:for-each</h1>
<p>  Data:  sq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the quote once for each value in the string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:format</h1>
<p>  Data:  ...s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Construct a new string using the template passed and items from the stack.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:get</h1>
<p>  Data:  -s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Read input from standard in (via `c:get`) until a CR or LF is encountered. Returns a strig.

</p>
<p>Class: class:word | Namespace: all | Interface Layer: rre</p>
<hr/>
<h1>s:hash</h1>
<p>  Data:  s-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Calculate a hash value for a string. This uses the djb2 algorithm.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:index-of</h1>
<p>  Data:  sc-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the location of the first instance of the specified character in the string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:index-of-string</h1>
<p>  Data:  ss-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the location of the first instance of the specified substring (s2) in the string (s1). Returns -1 if not found.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:keep</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Store a string into the heap and return a pointer to the start of it.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:left</h1>
<p>  Data:  sn-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a new string containing the first `n` characters from the source string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:length</h1>
<p>  Data:  s-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the number of characters in a string, excluding the NULL terminator.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:map</h1>
<p>  Data:  sq-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the specified quote once for each character in the string. Builds a new string from the return value of the quote. The quote should return only one value.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:prepend</h1>
<p>  Data:  ss-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a new string consisting of s2 followed by s1.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:put</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a string.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>s:replace</h1>
<p>  Data:  sss-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Replace the first instance of s2 in s1 with s3.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:reverse</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Reverse the order of ASCII characters in a string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:right</h1>
<p>  Data:  sn-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return a new string containing the specified number of characters from the right side of the string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:skip</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Internal helper function used to skip over a string in a definition.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:split</h1>
<p>  Data:  sc-ss
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Split a string on the first occurrance of the specified character.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:split-on-string</h1>
<p>  Data:  ss-ss
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Split a string on the first occurrance of the specified string. After the split, the top stack item will be the part of the string before the specified subsring, and the second item will be the rest of the original string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<xmp>
Example #1:

  'Hello_Brave_World! 'Brave s:split-on-string s:put nl s:put nl

</xmp><hr/>
<h1>s:substr</h1>
<p>  Data:  sfl-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Extract a substring from the specified string. This will take the characters starting at `f` and extend `l` characters in length.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:temp</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Move a string into the temporary string buffers.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:to-float</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -F

</p>
<p>Convert a string representation into a floating point value.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: rre</p>
<hr/>
<h1>s:to-lower</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert uppercase ASCII characters in a string to lowercase.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:to-number</h1>
<p>  Data:  s-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert a string to a number.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:to-upper</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Convert lowercase ASCII characters in a string to uppercase.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<hr/>
<h1>s:tokenize</h1>
<p>  Data:  sc-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Takes a string and a character to use as a separator. It splits the string into a set of substrings and returns a set containing pointers to each of them.

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>s:tokenize-on-string</h1>
<p>  Data:  ss-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Takes a string (s1) and a substring (s2)  use as a separator. It splits the string into a set of substrings and returns a set containing pointers to each of them.

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>s:trim</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Trim leading and trailing whitespace from a string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<xmp>
Example #1:

    '__hello__ s:trim

</xmp><hr/>
<h1>s:trim-left</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Trim leading whitespace from a string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<xmp>
Example #1:

    '__hello__ s:trim-left

</xmp><hr/>
<h1>s:trim-right</h1>
<p>  Data:  s-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Trim trailing whitespace from a string.

</p>
<p>Class: class:word | Namespace: s | Interface Layer: all</p>
<xmp>
Example #1:

    '__hello__ s:trim-right

</xmp><hr/>
<h1>set-hook</h1>
<p>  Data:  aa-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Patch the hook point in a2 to point to a1.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    :foo hook ;
    :bar #1 ;
    &bar &foo set-hook

</xmp><hr/>
<h1>set:contains-string?</h1>
<p>  Data:  sa-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if the string value is in the set or`FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:contains?</h1>
<p>  Data:  na-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return `TRUE` if the value is in the set or `FALSE` otherwise.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:counted-results</h1>
<p>  Data:  q-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Run a quote and construct a new set from the returned values. The quote should return the values and the number of values to put into the set.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:dup</h1>
<p>  Data:  a-b
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Make a copy of a set. Return the address of the copy.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:filter</h1>
<p>  Data:  aq-b
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>For each item in the initial set, run the specified quote. If the quote returns `TRUE`, copy the item into a new set. If `FALSE`, discard it. Returns a pointer to the new set.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:for-each</h1>
<p>  Data:  aq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute the quote once for each item in the set.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:from-string</h1>
<p>  Data:  s-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Create a new set with the characters in the source string.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:length</h1>
<p>  Data:  a-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the length of a set.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:make</h1>
<p>  Data:  q-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute quote. Return a new set containing the values the quote leaves on the stack. This is identical to doing `set:counted-results set:reverse`

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:map</h1>
<p>  Data:  aq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute quote once for each item in the set. Constructs a new set from the value returned by the quote.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:nth</h1>
<p>  Data:  an-b
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the actual address of the nth item in the set.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:reduce</h1>
<p>  Data:  pnq-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Takes a set, a starting value, and a quote. This will apply the quote to each item in the set; the quote should consume two values and return one.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>set:reverse</h1>
<p>  Data:  a-b
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Reverse the order of items in a set. This will return a new set.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>shift</h1>
<p>  Data:  mn-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Peform a bitwise shift of m by n bits. If n is positive, shift right. If negative, the shift will be to the left.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>sip</h1>
<p>  Data:  nq-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Run quote. After execution completes, put a copy of n back on top of the stack.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>sp</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a space (`ASCII:SPACE`)

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    :spaces (n-)  [ sp ] times ;
    #12 spaces

</xmp><hr/>
<h1>store</h1>
<p>  Data:  na-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Store a value into the specified address.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    'Base var
    #10 &Base store

</xmp><hr/>
<h1>store-next</h1>
<p>  Data:  na-a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Store a value into the specified address and return the next address.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>swap</h1>
<p>  Data:  nm-mn
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Exchange the position of the top two items on the stack

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>sys:argc</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the number of arguments passed to the program.

</p>
<p>Class: class:word | Namespace: sys | Interface Layer: rre</p>
<hr/>
<h1>sys:argv</h1>
<p>  Data:  n-s
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Given an argument number, return the argument as a string.

</p>
<p>Class: class:word | Namespace: sys | Interface Layer: rre</p>
<hr/>
<h1>tab</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a tab (`ASCII:HT`)

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>times</h1>
<p>  Data:  nq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Run the specified quote the specified number of times.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #12 [ $- c:put ] times

</xmp><hr/>
<h1>times&lt;with-index&gt;</h1>
<p>  Data:  nq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Run a quote the specified number of times, tracking the loop index in `I`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>tri</h1>
<p>  Data:  xqqq-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Apply q1 against x, then q2 against a copy of x, and finally q3 against another copy of x.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>tri*</h1>
<p>  Data:  xyzqqq-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Apply q1 against x, q2 against y, and q3 against z.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>tri@</h1>
<p>  Data:  xyzq-?
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Apply q against x, then against y, and finally against z.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>tuck</h1>
<p>  Data:  nm-mnm
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Put a copy of the top item on the stack under the second one.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>u:-INF</h1>
<p>  Data:  -u
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:-inf?</h1>
<p>  Data:  u-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:INF</h1>
<p>  Data:  -u
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:MAX</h1>
<p>  Data:  -u
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:MIN</h1>
<p>  Data:  -u
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:NAN</h1>
<p>  Data:  -u
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:clip</h1>
<p>  Data:  u-U
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:inf?</h1>
<p>  Data:  u-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:max?</h1>
<p>  Data:  u-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:min?</h1>
<p>  Data:  u-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:n?</h1>
<p>  Data:  u-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:nan?</h1>
<p>  Data:  u-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:to-f</h1>
<p>  Data:  u-
</p>
<p>  Addr:  -
</p>
<p>  Float: -n

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>u:zero?</h1>
<p>  Data:  u-f
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>{n/a}

</p>
<p>Class: class:word | Namespace: {n/a} | Interface Layer: {n/a}</p>
<hr/>
<h1>unhook</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Reset the hook point in a1 to the default definition.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    :foo hook #1 ;
    :bar #2 ;
    &bar &foo set-hook
    &foo unhook

</xmp><hr/>
<h1>unix:chdir</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Change the current working directory to the specified one.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<xmp>
Example #1:

  '/etc unix:chdir

</xmp><hr/>
<h1>unix:exec0</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute a process by running the application specified by s.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:exec1</h1>
<p>  Data:  ss-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute a process by running the application specified by s1. Pass s2 as an argument.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:exec2</h1>
<p>  Data:  sss-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute a process by running the application specified by s1. Pass s2 and s3 as arguments.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:exec3</h1>
<p>  Data:  ssss-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute a process by running the application specified by s1. Pass s2, s3, and s4 as arguments.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:exit</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Exit the current process, returning the specified return code.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:fork</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Fork the current process. Returns a PID.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:getenv</h1>
<p>  Data:  sa-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Get an environment variable. Provide the name and an address to store it in.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<xmp>
Example #1:

  'SHELL s:empty [ unix:getenv ] sip s:put nl

</xmp><hr/>
<h1>unix:getpid</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Return the PID of the current process.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:io:n:put</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a number (in base 10) to the standard output device. This is faster than `n:put`, but not portable.

</p>
<p>Class: class:word | Namespace: unix:io | Interface Layer: rre</p>
<hr/>
<h1>unix:io:s:put</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Display a string to stdout. This is faster than `s:put`, but not portable.

</p>
<p>Class: class:word | Namespace: unix:io | Interface Layer: rre</p>
<hr/>
<h1>unix:kill</h1>
<p>  Data:  nn-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Terminates a process. Takes a process and a signal to send.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:pclose</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Close a pipe.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:popen</h1>
<p>  Data:  sn-n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Open a pipe. Takes a command to run, and a file mode (`file:R` or `file:W`; `file:R+` may work on some systems). Returns a file ID usable with words in the `file:` namespace.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:putenv</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Takes a string in the form `name=value` and sets an environment variable named `name` to `value`.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<xmp>
Example #1:

  'EDITOR=vi unix:putenv

</xmp><hr/>
<h1>unix:sleep</h1>
<p>  Data:  n-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Sleep for the specified number of seconds.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:system</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Runs another application using the system shell and returns after execution is completed.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<xmp>
Example #1:

  'ls_-lh_/etc unix:system

</xmp><hr/>
<h1>unix:wait</h1>
<p>  Data:  -n
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Waits for a child process to complete. This maps to the wait() system call.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>unix:write</h1>
<p>  Data:  sh-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Write a string to the specified file handle.

</p>
<p>Class: class:word | Namespace: unix | Interface Layer: rre</p>
<hr/>
<h1>until</h1>
<p>  Data:  q-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute quote repeatedly while the quote returns a value of `FALSE`. The quote should return a flag of either `TRUE` or `FALSE`, though `until` will treat any non-zero value as `TRUE`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #10 [ dup n:put nl n:dec dup n:zero? ] until

</xmp><hr/>
<h1>v:dec</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Decrement the value stored at the specified address by 1.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:dec-by</h1>
<p>  Data:  na-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Decrement the value stored at the specified address by the specified value.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:inc</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Increment the value stored at the specified address by 1.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:inc-by</h1>
<p>  Data:  na-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Increment the value stored at the specified address by the specified value.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:limit</h1>
<p>  Data:  alu-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Fetch the value stored at the address, then run `n:limit` against it, using the specified lower and upper bounds. Then store the resulting value back to the original address.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:off</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Set a variable to 0.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:on</h1>
<p>  Data:  a-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Set a variable to -1.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:preserve</h1>
<p>  Data:  aq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Make a copy of the value at the address, then run the quote. Once the quote completes, restore the address to the specified value.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>v:update-using</h1>
<p>  Data:  aq-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Fetch a value from the specified address, then run the quotation with this value on the stack. Afterwards, store the returned value at the original address.

</p>
<p>Class: class:word | Namespace: v | Interface Layer: all</p>
<hr/>
<h1>var</h1>
<p>  Data:  s-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Create a variable. The variable is initialized to 0.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    'Base var

</xmp><hr/>
<h1>var&lt;n&gt;</h1>
<p>  Data:  ns-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Create a variable with the specified initial value.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #10 'Base var<n>


</xmp><hr/>
<h1>while</h1>
<p>  Data:  q-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Execute quote repeatedly while the quote returns a `TRUE` value. The quote should return a flag of either `TRUE` or `FALSE`, though `while` will treat any non-zero value as `TRUE`.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<xmp>
Example #1:

    #10 [ dup n:put nl n:dec dup n:-zero? ] while

</xmp><hr/>
<h1>xor</h1>
<p>  Data:  mn-o
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Perform a bitwise XOR operation.

</p>
<p>Class: class:primitive | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>{</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Begin a set. This is intended to make creating sets a bit cleaner than using a quotation and `set:counteh-results`.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>{{</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Begin a lexically scoped area.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>}</h1>
<p>  Data:  -a
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>Complete a set begun by `{`. Returns a pointer to the data.

</p>
<p>Class: class:word | Namespace: set | Interface Layer: all</p>
<hr/>
<h1>}as</h1>
<p>  Data:  f-
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>End an assembly section.

</p>
<p>Class: class:macro | Namespace: global | Interface Layer: all</p>
<hr/>
<h1>}}</h1>
<p>  Data:  -
</p>
<p>  Addr:  -
</p>
<p>  Float: -

</p>
<p>End a lexically scoped area.

</p>
<p>Class: class:word | Namespace: global | Interface Layer: all</p>
<hr/>
